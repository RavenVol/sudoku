export const candidates = {
  "00": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "01": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "02": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "03": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "04": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "05": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "06": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "07": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "08": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "10": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "11": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "12": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "13": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "14": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "15": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "16": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "17": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "18": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "20": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "21": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "22": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "23": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "24": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "25": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "26": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "27": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "28": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "30": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "31": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "32": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "33": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "34": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "35": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "36": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "37": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "38": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "40": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "41": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "42": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "43": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "44": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "45": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "46": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "47": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "48": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "50": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "51": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "52": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "53": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "54": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "55": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "56": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "57": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "58": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "60": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "61": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "62": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "63": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "64": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "65": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "66": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "67": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "68": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "70": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "71": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "72": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "73": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "74": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "75": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "76": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "77": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "78": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "80": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "81": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "82": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "83": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "84": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "85": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "86": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "87": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "88": [1, 2, 3, 4, 5, 6, 7, 8, 9]
};


export const getSolution = (solution, candidates) => {
  prepareCandidates(solution, candidates);

  let count = 1;
  while (count > 0) {
    count = 0;
    for (let row = 0; row <= 8; row++) {
      for (let coll = 0; coll <= 8; coll++) {
        if (solution[row][coll] === 0) {
          count += removeCandidatesForRow(row, coll, solution, candidates, count);
          count += removeCandidatesForColl(row, coll, solution, candidates, count);
          count += removeCandidatesForBox(row, coll, solution, candidates, count);

          if (candidates[`${row}${coll}`].length === 1) {
            solution[row][coll] = candidates[`${row}${coll}`][0];
            count++;
          }
        }
      }
    }

    if (count === 0) {count += uniqInBox(candidates, solution, count);}
    if (count === 0) {count += uniqInRow(candidates, solution, count);}
    if (count === 0) {count += uniqInCol(candidates, solution, count);}
  }

  if (isSolutionCorrect(solution)) {
    return solution;
  } else {
    console.log('Only partial solution available');
    return solution;
  }
}

const prepareCandidates = (solution, candidates) => {
  for (let row = 0; row <= 8; row++) {
    for (let coll = 0; coll <= 8; coll++) {
      if (solution[row][coll] !== 0) {
        candidates[`${row}${coll}`] = [solution[row][coll]];
      }
    }
  }
}

const removeCandidatesForRow = (x, y, solution, candidates, count) => {
  for (let coll = 0; coll <= 8; coll++) {
    if ( solution[x][coll] !== 0 ) {
      for (let col = 0; col <= 8; col++) {
        if (candidates[`${x}${col}`].includes(solution[x][coll])) {
          let index = candidates[`${x}${col}`].indexOf(solution[x][coll]);
          if (index >= 0 && candidates[`${x}${col}`].length > 1) {
            candidates[`${x}${col}`].splice(index, 1);
            count++;
          }
        }
      }
    }
  }
  return count;
}

const removeCandidatesForColl = (x, y, solution, candidates, count) => {
  for (let row = 0; row <= 8; row++) {
    if ( solution[row][y] !== 0 ) {
      for (let r = 0; r <= 8; r++) {
        if (candidates[`${r}${y}`].includes(solution[row][y])) {
          let index = candidates[`${r}${y}`].indexOf(solution[row][y]);
          if (index >= 0 && candidates[`${r}${y}`].length > 1) {
            candidates[`${r}${y}`].splice(index, 1);
            count++;
          }
        }
      }
    }
  }
  return count;
}

const removeCandidatesForBox = (x, y, solution, candidates, count) => {
  const xStart = Math.ceil((x + 1) / 3 - 1) * 3;
  const xEnd = xStart + 2;
  const yStart = Math.ceil((y + 1) / 3 - 1) * 3;
  const yEnd = yStart + 2;
  const boxNumbers = [];

  for (let row = xStart; row <= xEnd; row++) {
    for (let col = yStart; col <= yEnd; col++) {
      if (solution[row][col]) {
        boxNumbers.push(solution[row][col]);
      }
    }
  }

  for (let i = 0; i < boxNumbers.length; i++) {
    if (candidates[`${x}${y}`].length > 1 && candidates[`${x}${y}`].includes(boxNumbers[i])) {
      let index = candidates[`${x}${y}`].indexOf(boxNumbers[i]);
      candidates[`${x}${y}`].splice(index, 1);
      count++;
    }
  }
  return count;
}

const uniqInRow = (candidates, solution, count) => {
  for (let x = 0; x <= 8; x++) {
    let candArray = [];
    let uniq = [];

    for (let y = 0; y <= 8; y++) {
      if (candidates[`${x}${y}`].length > 1) {
        candArray = [...candArray, ...candidates[`${x}${y}`]];
      }
    }

    for (let i = 0; i < candArray.length; i++) {
      uniq.push(candArray.filter(number => number === candArray[i]).length === 1 && candArray[i]);
    }
    uniq = uniq.filter(number => typeof(number) === 'number');

    if (uniq.length === 1) {
      for (let y = 0; y <= 8; y++) {
        if (candidates[`${x}${y}`].includes(uniq[0])) {
          candidates[`${x}${y}`] = [uniq[0]];
          solution[x][y] = uniq[0];
          count++;
        }
      }
    }
  }
  return count;
}

const uniqInCol = (candidates, solution, count) => {
  for (let y = 0; y <= 8; y++) {
    let candArray = [];
    let uniq = [];

    for (let x = 0; x <= 8; x++) {
      if (candidates[`${x}${y}`].length > 1) {
        candArray = [...candArray, ...candidates[`${x}${y}`]];
      }
    }

    for (let i = 0; i < candArray.length; i++) {
      uniq.push(candArray.filter(number => number === candArray[i]).length === 1 && candArray[i]);
    }
    uniq = uniq.filter(number => typeof(number) === 'number');

    if (uniq.length === 1) {
      for (let x = 0; x <= 8; x++) {
        if (candidates[`${x}${y}`].includes(uniq[0])) {
          candidates[`${x}${y}`] = [uniq[0]];
          solution[x][y] = uniq[0];
          count++;
        }
      }
    }
  }
  return count;
}

const uniqInBox = (candidates, solution, count) => {
  for (let x = 0; x <= 2; x++) {
    for (let y = 0; y <= 2; y++) {
      let candArray = [];
      let uniq = [];
      for (let row = x * 3; row <= x * 3 + 2; row++) {
        for (let col = y * 3; col <= y * 3 + 2; col++) {
          candArray = [...candArray, ...candidates[`${x}${y}`]];
        }
      }

      for (let i = 0; i < candArray.length; i++) {
        uniq.push(candArray.filter(number => number === candArray[i]).length === 1 && candArray[i]);
      }
      uniq = uniq.filter(number => typeof(number) === 'number');

      if (uniq.length === 1) {
        for (let row = x * 3; row <= x * 3 + 2; row++) {
          for (let col = y * 3; col <= y * 3 + 2; col++) {
            if (candidates[`${row}${col}`].includes(uniq[0])) {
              candidates[`${row}${col}`] = [uniq[0]];
              solution[row][col] = uniq[0];
              count++;
            }
          }
        }
      }
    }
  }
  return count;
}

const tryStrongCandidate = (candidates, solution) => {
  const expectedSolution = solution.map(row => row.map(item => item));
  const expectedCandidates = {};
  for (let row = 0; row <= 8; row++) {
    for (let col = 0; col <= 8; col++) {
      expectedCandidates[`${row}${col}`] = candidates[`${row}${col}`].map(item => item);
    }
  }

  let trySolution = [];

  for (let row = 0; row <= 8; row++) {
    for (let col = 0; col <= 8; col++) {
      if (candidates[`${row}${col}`].length === 2) {
        expectedCandidates[`${row}${col}`] = [candidates[`${row}${col}`][0]];
        expectedSolution[row][col] = candidates[`${row}${col}`][0];

        trySolution = getSolution(expectedSolution, expectedCandidates);

        if (isSolutionCorrect(trySolution)) {
          return trySolution;
        }

        expectedCandidates[`${row}${col}`] = [candidates[`${row}${col}`][1]];
        expectedSolution[row][col] = candidates[`${row}${col}`][1];

        trySolution = getSolution(expectedSolution, expectedCandidates);

        if (isSolutionCorrect(trySolution)) {
          return trySolution;
        }
      }
    }
  }
}

export const isSolutionCorrect = (trySolution) => {
 let tryRow = [];
 let tryCol = [];
 let tryBox = [];

  for (let row = 0; row <= 8; row++) {
    tryRow = [];
    for (let col = 0; col <= 8; col++) {
      if (tryRow.includes(trySolution[row][col])) {
        return false;
      }

      tryRow.push(trySolution[row][col]);
    }
  }

  for (let col = 0; col <= 8; col++) {
    tryCol = [];
    for (let row = 0; row <= 8; row++) {
      if (tryCol.includes(trySolution[row][col])) {
        return false;
      }

      tryCol.push(trySolution[row][col]);
    }
  }

  for (let x = 0; x <= 2; x++) {
    for (let y = 0; y <= 2; y++) {
      tryBox = [];
      for (let row = x * 3; row <= x * 3 + 2; row++) {
        for (let col = y * 3; col <= y * 3 + 2; col++) {
          if (tryBox.includes(trySolution[row][col])) {
            return false;
          }

          tryBox.push(trySolution[row][col]);
        }
      }
    }
  }

  return true;
}

export const createSudoku = (candidates, zeros) => {
  let solvedSudoku = [];
  let sudoku = [];
  let randomizer = 0;
  const shufflePatterns = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]];
  let startNumber = Math.ceil(Math.random() * 9);

  for (let boxLine = 0; boxLine <= 2; boxLine++) {
    for (let boxRow = 0; boxRow <= 2; boxRow++) {
      sudoku.push([]);
      for (let col = 0; col <= 8; col++) {
        sudoku[boxLine * 3 + boxRow].push(startNumber + col);
        if (sudoku[boxLine * 3 + boxRow][col] > 9) {
          sudoku[boxLine * 3 + boxRow][col] -= 9;
        }
      }
      startNumber += 3;
      startNumber = startNumber > 9 ? startNumber - 9 : startNumber;
    }
    startNumber += 1;
    startNumber = startNumber > 9 ? startNumber - 9 : startNumber;
  }

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = [...makeBoxRowShuffle(sudoku, shufflePatterns[randomizer])];

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeBoxColShuffle(sudoku, shufflePatterns[randomizer]);

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeRowShuffle(sudoku, shufflePatterns[randomizer], 0);

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeRowShuffle(sudoku, shufflePatterns[randomizer], 1);

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeRowShuffle(sudoku, shufflePatterns[randomizer], 2);

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeColShuffle(sudoku, shufflePatterns[randomizer], 0);

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeColShuffle(sudoku, shufflePatterns[randomizer], 1);

  randomizer = Math.ceil(Math.random() * 6) - 1;
  sudoku = makeColShuffle(sudoku, shufflePatterns[randomizer], 2);

  solvedSudoku = sudoku.map(row => row.map(cell => cell));

   let zeroCount = 0;
   while (zeroCount < zeros) {
     let row = Math.floor(Math.random() * 9);
     let col = Math.floor(Math.random() * 9);

     let reserv = sudoku[row][col];
     sudoku[row][col] = 0;
     let trySudoku = sudoku.map(row => row.map(item => item));

     if (!isSolutionCorrect(getSolution(trySudoku, candidates))) {
       sudoku[row][col] = reserv;
     }

     zeroCount = 0;
     for (let row = 0; row <= 8; row++) {
       for (let col = 0; col <= 8; col++) {
         if (sudoku[row][col] === 0) {
           zeroCount++;
         }
       }
     }
   }

  return [sudoku, solvedSudoku];
};

const makeBoxRowShuffle = (sudoku, pattern) => {
  const shuffledSudoku = [];

  for (let boxLine = 0; boxLine <= 2; boxLine++) {
    for (let row = 0; row <= 2; row++) {
      for (let col = 0; col <= 8; col++) {
        shuffledSudoku[boxLine * 3 + row] = [...sudoku[pattern[boxLine] * 3 + row]];
      }
    }
  }

  return shuffledSudoku;
};

const makeBoxColShuffle = (sudoku, pattern) => {
  const shuffledSudoku = [];

  for (let row = 0; row <= 8; row++) {
    shuffledSudoku.push([]);
    for (let boxCol = 0; boxCol <= 2; boxCol++) {
      for (let col = 0; col <= 2; col++) {
        shuffledSudoku[row].push(sudoku[row][pattern[boxCol] * 3 + col]);
      }
    }
  }

  return shuffledSudoku;
};

const makeRowShuffle = (sudoku, pattern, boxLine) => {
  const shuffledSudoku = sudoku.map(row => row.map(item => item));

  for (let row = 0; row <= 2; row++) {
    for (let col = 0; col <= 8; col++) {
      shuffledSudoku[boxLine * 3 + row][col] = sudoku[boxLine * 3 + pattern[row]][col];
    }
  }

  return shuffledSudoku;
};

const makeColShuffle = (sudoku, pattern, boxCol) => {
  const shuffledSudoku = sudoku.map(row => row.map(item => item));

  for (let col = 0; col <= 2; col++) {
    for (let row = 0; row <= 8; row++) {
      shuffledSudoku[row][boxCol * 3 + col] = sudoku[row][boxCol * 3 + pattern[col]];
    }
  }

  return shuffledSudoku;
};

